"""
UploadFile Command - Handle file upload with validation and registration.

Flow:
1. Validate filename and extension
2. Create upload directory
3. Check for duplicate file
4. Save file to disk
5. Create FileRegistry entity (ID auto-generated by Prisma cuid())
6. Save to database (no meta.json)
7. Return result

Note: This matches the original Flask upload.py logic, but without meta.json file.
The file_id is auto-generated by Prisma, not MD5 hash.
"""

import os
import hashlib
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import Optional

from src.application.common.interfaces import Command, CommandHandler
from src.domain.entities.file_registry import FileRegistry
from src.domain.ports.repositories.file_registry_repository import FileRegistryRepository
from src.domain.value_objects.user_email import UserEmail
from src.domain.value_objects.dept_id import DeptId
from src.domain.value_objects.file_path import FilePath
from src.utils.file_utils import validate_filename_str, create_upload_dir, canonical_path
from src.config.settings import Config


# MIME type mapping (same as Flask upload.py)
MIME_TYPE_MAP = {
    "pdf": "application/pdf",
    "doc": "application/msword",
    "docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "xls": "application/vnd.ms-excel",
    "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "ppt": "application/vnd.ms-powerpoint",
    "pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "txt": "text/plain",
    "csv": "text/csv",
    "md": "text/markdown",
    "json": "application/json",
    "xml": "application/xml",
    "html": "text/html",
}


def _make_metadata_id(filename: str) -> str:
    """Generate MD5 hash ID from filename (for metadata, not DB id)."""
    return hashlib.md5(filename.encode("utf-8")).hexdigest()


def _get_mime_type(ext: str, content_type: Optional[str] = None) -> str:
    """Get MIME type from extension or fallback to content_type."""
    return MIME_TYPE_MAP.get(ext.lower(), content_type or "application/octet-stream")


# ==================== RESULT ====================


@dataclass
class UploadFileResult:
    """Result of file upload operation."""

    file_id: str
    storage_path: str
    filename: str


# ==================== COMMAND ====================


@dataclass(frozen=True)
class UploadFileCommand(Command[UploadFileResult]):
    """
    Command to upload a file.

    Args:
        user_email: User's email (value object)
        dept_id: Department ID (value object)
        filename: Original filename from upload
        content: File binary content
        content_type: MIME type from request (optional)
        tags: List of tags (optional)
        file_for_user: True = user-specific folder, False = shared folder
    """

    user_email: UserEmail
    dept_id: DeptId
    filename: str
    content: bytes
    content_type: Optional[str] = None
    tags: list[str] = field(default_factory=list)
    file_for_user: bool = False


# ==================== HANDLER ====================


class UploadFileHandler(CommandHandler[UploadFileResult]):
    """
    Handler for file upload command.

    Saves file to disk and registers in database.
    No meta.json file is created - all metadata stored in DB.
    """

    def __init__(self, file_registry_repository: FileRegistryRepository):
        self._repo = file_registry_repository

    async def execute(self, command: UploadFileCommand) -> UploadFileResult:
        # 1. Validate filename and extension (with optional MIME check)
        filename = validate_filename_str(
            command.filename,
            allowed_extensions=Config.ALLOWED_EXTENSIONS,
            content=command.content,
            mime_types=Config.MIME_TYPES,
        )
        if not filename:
            raise ValueError("File is not valid mime type or extension")

        # 2. Determine upload directory
        user_folder = (
            command.user_email.value if command.file_for_user else Config.FOLDER_SHARED
        )
        upload_dir = create_upload_dir(
            base_path=Config.UPLOAD_BASE,
            dept_id=command.dept_id.value,
            user_id=user_folder,
        )
        if not upload_dir:
            raise ValueError("Failed to create upload directory")

        # 3. Build file path and check for duplicate
        file_path = canonical_path(upload_dir, filename)
        if os.path.exists(file_path):
            raise ValueError("File with the same name already exists")

        # 4. Save file to disk
        with open(file_path, "wb") as f:
            f.write(command.content)

        # 5. Prepare metadata (matching Flask upload.py file_info structure)
        file_size_bytes = len(command.content)
        ext = filename.rsplit(".", 1)[1].lower() if "." in filename else ""
        mime_type = _get_mime_type(ext, command.content_type)
        tags_str = ",".join(command.tags) if command.tags else ""
        now = datetime.now(timezone.utc)

        # Build metadata dict (same structure as Flask's file_info)
        metadata = {
            "file_id": _make_metadata_id(filename),  # MD5 hash for legacy compatibility
            "file_path": str(file_path),
            "filename": filename,
            "source": filename,
            "ext": ext,
            "size_kb": round(file_size_bytes / 1024, 1),
            "tags": tags_str,
            "upload_at": now.isoformat(),
            "uploaded_at_ts": now.timestamp(),
            "user_id": command.user_email.value,
            "dept_id": command.dept_id.value,
            "file_for_user": command.file_for_user,
            "ingested": False,
        }

        # 6. Create FileRegistry entity (id=None, will be auto-generated)
        file_registry = FileRegistry(
            user_email=command.user_email,
            category="uploaded",
            original_name=filename,
            storage_path=FilePath(str(file_path)),
            created_at=now,
            accessed_at=now,
            id=None,  # Auto-generated by Prisma
            dept_id=command.dept_id,
            download_url=None,  # Set by repository after ID is generated
            mime_type=mime_type,
            size_bytes=file_size_bytes,
            source_tool="upload_ui",
            indexed_in_chromadb=False,
            metadata=metadata,
        )

        # 7. Create in database (repository generates ID and download_url)
        created_file = await self._repo.create(file_registry)

        # 8. Return result with generated ID
        return UploadFileResult(
            file_id=created_file.id,
            storage_path=str(file_path),
            filename=filename,
        )