"""
FileService - Application service for file operations.

Coordinates between:
- FileStorageService (disk I/O - sync)
- FileRegistryRepository (database - async)

This service is ASYNC because it uses the async repository.
All public methods are async.

Replaces the old FileManager class with a cleaner architecture.
"""

import os
import logging
from datetime import datetime, timezone
from typing import Optional, Dict, List, Any

from src.infrastructure.storage import FileStorageService
from src.domain.ports.repositories.file_registry_repository import FileRegistryRepository
from src.domain.entities.file_registry import FileRegistry
from src.domain.value_objects.file_id import FileId
from src.domain.value_objects.user_email import UserEmail
from src.domain.value_objects.dept_id import DeptId
from src.domain.value_objects.file_path import FilePath
from src.domain.value_objects.conversation_id import ConversationId
from src.config.settings import Config

logger = logging.getLogger(__name__)


class FileService:
    """
    Application service for file operations.

    Coordinates disk I/O (FileStorageService) with database
    registration (FileRegistryRepository).

    Usage:
        # Injected via DI container
        class MyHandler:
            def __init__(self, file_service: FileService):
                self.file_service = file_service

            async def handle(self):
                file_id = await self.file_service.save_chat_attachment(...)
    """

    # File categories
    CATEGORY_CHAT = "chat"
    CATEGORY_UPLOADED = "uploaded"
    CATEGORY_DOWNLOADED = "downloaded"
    CATEGORY_CREATED = "created"

    def __init__(
        self,
        storage: FileStorageService,
        repository: FileRegistryRepository,
    ):
        """
        Initialize FileService.

        Args:
            storage: FileStorageService for disk operations
            repository: FileRegistryRepository for database operations
        """
        self._storage = storage
        self._repository = repository

    async def save_chat_attachment(
        self,
        user_email: str,
        filename: str,
        content: bytes,
        mime_type: str,
        conversation_id: Optional[str] = None,
        dept_id: Optional[str] = None,
    ) -> str:
        """
        Save chat attachment to disk and register in database.

        Args:
            user_email: User email
            filename: Original filename
            content: File content as bytes
            mime_type: MIME type
            conversation_id: Chat session ID
            dept_id: Department ID

        Returns:
            file_id: Unique identifier for the saved file
        """
        # 1. Save to disk
        directory = self._storage.get_chat_attachment_dir(user_email)
        storage_path = self._storage.save_file(
            content=content,
            directory=directory,
            filename=filename,
            make_unique=True,
        )

        # 2. Register in database
        now = datetime.now(timezone.utc)
        file_entity = FileRegistry(
            user_email=UserEmail(user_email),
            category=self.CATEGORY_CHAT,
            original_name=filename,
            storage_path=FilePath(storage_path),
            created_at=now,
            accessed_at=now,
            id=None,  # Auto-generated by Prisma
            dept_id=DeptId(dept_id) if dept_id else None,
            download_url=None,  # Set after creation
            mime_type=mime_type,
            size_bytes=len(content),
            source_tool="chat_upload",
            conversation_id=ConversationId(conversation_id) if conversation_id else None,
            metadata={"file_for_user": True},  # Chat attachments are private
        )

        created = await self._repository.create(file_entity)

        logger.info(
            f"[FileService] Saved chat attachment: {created.id} | "
            f"user={user_email} | file={filename} | size={len(content)} bytes"
        )

        return created.id

    async def save_downloaded_file(
        self,
        user_email: str,
        filename: str,
        content: bytes,
        mime_type: str,
        source_url: Optional[str] = None,
        conversation_id: Optional[str] = None,
        dept_id: Optional[str] = None,
    ) -> Dict[str, str]:
        """
        Save downloaded file to disk and register in database.

        Args:
            user_email: User email
            filename: Filename
            content: File content as bytes
            mime_type: MIME type
            source_url: Original URL the file was downloaded from
            conversation_id: Chat session ID
            dept_id: Department ID

        Returns:
            Dict with file_id and download_url
        """
        # 1. Save to disk
        directory = self._storage.get_downloaded_files_dir(user_email)
        storage_path = self._storage.save_file(
            content=content,
            directory=directory,
            filename=filename,
            make_unique=True,
        )

        # 2. Register in database
        now = datetime.now(timezone.utc)
        file_entity = FileRegistry(
            user_email=UserEmail(user_email),
            category=self.CATEGORY_DOWNLOADED,
            original_name=filename,
            storage_path=FilePath(storage_path),
            created_at=now,
            accessed_at=now,
            id=None,
            dept_id=DeptId(dept_id) if dept_id else None,
            download_url=None,
            mime_type=mime_type,
            size_bytes=len(content),
            source_tool="download_file",
            source_url=source_url,
            conversation_id=ConversationId(conversation_id) if conversation_id else None,
            metadata={"file_for_user": True},
        )

        created = await self._repository.create(file_entity)

        logger.info(
            f"[FileService] Saved downloaded file: {created.id} | "
            f"user={user_email} | file={filename}"
        )

        return {"file_id": created.id, "download_url": created.download_url}

    async def save_file_and_register(
        self,
        user_email: str,
        category: str,
        filename: str,
        content: bytes,
        mime_type: str,
        source_tool: str,
        conversation_id: Optional[str] = None,
        dept_id: Optional[str] = None,
        source_url: Optional[str] = None,
        metadata: Optional[Dict] = None,
    ) -> Dict[str, str]:
        """
        Save file content to disk and register in database.

        This is a convenience method that combines disk save + DB registration.
        For cases where the file is already on disk, use register_file() instead.

        Args:
            user_email: User email
            category: File category (chat, uploaded, downloaded, created)
            filename: Filename
            content: File content as bytes
            mime_type: MIME type
            source_tool: Tool that created the file
            conversation_id: Chat session ID
            dept_id: Department ID
            source_url: Original URL (for downloaded files)
            metadata: Additional metadata

        Returns:
            Dict with file_id and download_url
        """
        # Determine directory based on category
        if category == self.CATEGORY_CHAT:
            directory = self._storage.get_chat_attachment_dir(user_email)
        elif category == self.CATEGORY_CREATED:
            directory = self._storage.get_created_files_dir(user_email)
        elif category == self.CATEGORY_DOWNLOADED:
            directory = self._storage.get_downloaded_files_dir(user_email)
        else:
            # For uploaded or unknown, use a generic path
            directory = self._storage.create_download_dir(user_email, category)

        # 1. Save to disk
        storage_path = self._storage.save_file(
            content=content,
            directory=directory,
            filename=filename,
            make_unique=True,
        )

        # 2. Register in database
        return await self.register_file(
            user_email=user_email,
            category=category,
            original_name=filename,
            storage_path=storage_path,
            source_tool=source_tool,
            mime_type=mime_type,
            size_bytes=len(content),
            conversation_id=conversation_id,
            dept_id=dept_id,
            source_url=source_url,
            metadata=metadata or {"file_for_user": True},
        )

    async def get_file_path(
        self,
        file_ref: str,
        user_email: str,
        dept_id: Optional[str] = None,
    ) -> str:
        """
        Resolve file reference to absolute storage path.

        Supports multiple reference formats:
        - File ID: "cmjg8yrab0000..."
        - API URL: "/api/files/{file_id}"
        - Filename: "report.pdf" (searches user's files)

        Args:
            file_ref: File reference string
            user_email: User email for security check
            dept_id: Department ID for shared file access

        Returns:
            Absolute path to file on disk

        Raises:
            FileNotFoundError: File doesn't exist or no access
        """
        # Handle /api/files/{file_id} format
        if file_ref.startswith("/api/files/"):
            file_ref = file_ref.replace("/api/files/", "")

        # Handle /api/downloads/{user}/{filename} format (legacy)
        if file_ref.startswith("/api/downloads/"):
            parts = file_ref.replace("/api/downloads/", "").split("/", 1)
            if len(parts) == 2:
                user_id, filename = parts
                import urllib.parse
                filename = urllib.parse.unquote(filename)
                file_path = os.path.join(Config.DOWNLOAD_BASE, user_id, filename)
                if os.path.exists(file_path):
                    return file_path
                file_ref = filename  # Fallback to filename search

        # Try to get by file ID
        file_entity = await self._repository.get_accessible_file(
            file_id=FileId(file_ref),
            user_email=UserEmail(user_email),
            dept_id=DeptId(dept_id) if dept_id else DeptId(""),
        )

        if file_entity:
            # Verify file exists on disk
            if self._storage.file_exists(file_entity.storage_path.value):
                return file_entity.storage_path.value
            else:
                logger.error(
                    f"[FileService] File in DB but missing on disk: {file_entity.storage_path.value}"
                )
                raise FileNotFoundError(f"File registered but not found on disk: {file_ref}")

        # Try to find by filename
        file_entity = await self._repository.find_by_name(
            user_email=UserEmail(user_email),
            original_name=file_ref,
        )

        if file_entity:
            if self._storage.file_exists(file_entity.storage_path.value):
                return file_entity.storage_path.value

        raise FileNotFoundError(f"File not found: {file_ref} for user {user_email}")

    async def get_file_by_id(
        self,
        file_id: str,
        user_email: str,
        dept_id: Optional[str] = None,
    ) -> Optional[FileRegistry]:
        """
        Get file entity by ID with access check.

        Args:
            file_id: File ID
            user_email: User email for security check
            dept_id: Department ID for shared file access

        Returns:
            FileRegistry entity if accessible, None otherwise
        """
        return await self._repository.get_accessible_file(
            file_id=FileId(file_id),
            user_email=UserEmail(user_email),
            dept_id=DeptId(dept_id) if dept_id else DeptId(""),
        )

    async def list_files(
        self,
        user_email: str,
        dept_id: Optional[str] = None,
        category: Optional[str] = None,
        conversation_id: Optional[str] = None,
        limit: int = 50,
    ) -> List[Dict[str, Any]]:
        """
        List files available to user.

        Args:
            user_email: User email
            dept_id: Department ID for shared file access
            category: Filter by category
            conversation_id: Filter by conversation
            limit: Maximum number of files

        Returns:
            List of file info dictionaries
        """
        if dept_id:
            # Get accessible files (user's own + shared in dept)
            files = await self._repository.get_accessible_files(
                user_email=UserEmail(user_email),
                dept_id=DeptId(dept_id),
                category=category,
                limit=limit,
            )
        else:
            # Get only user's own files
            files = await self._repository.get_by_user(
                user_email=UserEmail(user_email),
                category=category,
                conversation_id=ConversationId(conversation_id) if conversation_id else None,
                limit=limit,
            )

        return [
            {
                "id": f.id,
                "category": f.category,
                "original_name": f.original_name,
                "download_url": f.download_url,
                "mime_type": f.mime_type,
                "size_bytes": f.size_bytes,
                "created_at": f.created_at.isoformat() if f.created_at else None,
                "source_tool": f.source_tool,
                "source_url": f.source_url,  # For downloaded files - shows original URL
                "indexed_in_chromadb": f.indexed_in_chromadb,  # For RAG status display
            }
            for f in files
        ]

    async def delete_file(
        self,
        file_id: str,
        user_email: str,
    ) -> bool:
        """
        Delete file from both disk and database.

        Args:
            file_id: File ID to delete
            user_email: User email for ownership check

        Returns:
            True if deleted successfully

        Raises:
            PermissionError: User doesn't own the file
        """
        # Get file with ownership check
        file_entity = await self._repository.get_by_id_and_user(
            file_id=FileId(file_id),
            user_email=UserEmail(user_email),
        )

        if not file_entity:
            raise PermissionError(
                f"File not found or access denied: {file_id} for user {user_email}"
            )

        # Delete from disk
        self._storage.delete_file(file_entity.storage_path.value)

        # Delete from database
        await self._repository.delete(FileId(file_id))

        logger.info(f"[FileService] Deleted file: {file_id}")
        return True

    async def register_file(
        self,
        user_email: str,
        category: str,
        original_name: str,
        storage_path: str,
        source_tool: str,
        mime_type: Optional[str] = None,
        size_bytes: Optional[int] = None,
        conversation_id: Optional[str] = None,
        dept_id: Optional[str] = None,
        source_url: Optional[str] = None,
        indexed_in_chromadb: bool = False,
        metadata: Optional[Dict] = None,
    ) -> Dict[str, str]:
        """
        Register an existing file in the database.

        Use this when file is already saved to disk (e.g., by upload handler).

        Args:
            user_email: User email
            category: File category
            original_name: Original filename
            storage_path: Absolute path to file on disk
            source_tool: Tool that created the file
            mime_type: MIME type
            size_bytes: File size
            conversation_id: Chat session ID
            dept_id: Department ID
            source_url: Original URL
            indexed_in_chromadb: Whether indexed in vector DB
            metadata: Additional metadata

        Returns:
            Dict with file_id and download_url
        """
        now = datetime.now(timezone.utc)
        file_entity = FileRegistry(
            user_email=UserEmail(user_email),
            category=category,
            original_name=original_name,
            storage_path=FilePath(storage_path),
            created_at=now,
            accessed_at=now,
            id=None,
            dept_id=DeptId(dept_id) if dept_id else None,
            download_url=None,
            mime_type=mime_type,
            size_bytes=size_bytes,
            source_tool=source_tool,
            source_url=source_url,
            conversation_id=ConversationId(conversation_id) if conversation_id else None,
            indexed_in_chromadb=indexed_in_chromadb,
            metadata=metadata or {},
        )

        created = await self._repository.create(file_entity)

        logger.info(
            f"[FileService] Registered file: {created.id} | "
            f"user={user_email} | category={category} | name={original_name}"
        )

        return {"file_id": created.id, "download_url": created.download_url}
